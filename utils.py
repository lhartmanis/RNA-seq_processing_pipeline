import shutil, os, re, glob, json
import time
from datetime import datetime
import subprocess

#def rename_files(input_dir, config_file, mapping_file):
#    """
#    Renames files in the input directory based on the sample name and metadata.
#
#    Args:
#        input_dir (str): Path to the input directory containing FASTQ files.
#        config_file (str): Path to the configuration file.
#        mapping_file (str): Path to save the renaming map as a JSON file.
#    """
#    # Define a regex pattern to match filenames with metadata
#    #pattern = re.compile(r"(?P<sample>[^_]+)_(?P<meta>[^_]+)_R(?P<read>[12])_(?P<more_meta>.+)\.fastq\.gz")
#    pattern = re.compile(r"(?P<sample>[^_]+)(?:_(?P<meta>[^_]+))?_R(?P<read>[12])(?:_(?P<more_meta>.+))?\.fastq\.gz")
#    # Dictionary to store the renaming map
#    renaming_map = {}
#
#    # Iterate over files in the input directory
#    for filename in os.listdir(input_dir):
#        match = pattern.match(filename)
#        if match:
#            # Extract components from the filename
#            sample = match.group("sample")
#            read = match.group("read")
#
#            # Construct the new filename
#            new_filename = f"{sample}_R{read}.fastq.gz"
#
#            # Rename the file
#            old_path = os.path.join(input_dir, filename)
#            new_path = os.path.join(input_dir, new_filename)
#            os.rename(old_path, new_path)
#
#            # Update the renaming map
#            renaming_map[filename] = new_filename
#
#    # Save the renaming map to a JSON file
#    with open(mapping_file, "w") as f:
#        json.dump(renaming_map, f, indent=4)
#
#    print(f"Renaming completed. Mapping saved to {mapping_file}.")

def rename_files(input_dir, samples, mapping_file, target_sample):
    """
    Renames files in the input directory based on the sample name and metadata.

    Args:
        input_dir (str): Path to the input directory containing FASTQ files.
        samples (list): List of sample names.
        mapping_file (str): Path to save the renaming map as a JSON file.
    """
    def rename_file(orig_filename, new_filename, input_dir, renaming_map, mapping_file):
        """
        Helper function to rename a file and update the renaming map.

        Args:
            orig_filename (str): Original filename.
            new_filename (str): New filename.
            input_dir (str): Directory containing the files.
            renaming_map (dict): Dictionary to store the renaming map.
        """
        old_path = os.path.join(input_dir, orig_filename)
        new_path = os.path.join(input_dir, new_filename)
        print(f"Renaming: {old_path} -> {new_path}")
        os.rename(old_path, new_path)
        renaming_map[old_path] = new_path
        # Save the renaming map to a JSON file
        with open(mapping_file, "w") as f:
            json.dump(renaming_map, f, indent=4)

    files = os.listdir(input_dir)
    renaming_map = {}

    # Iterate over files in the input directory
    for sample in samples:
        if sample != target_sample:
            continue
        # Find files matching the sample name
        sample_files = [i for i in files if sample in i]
        if len(sample_files) == 0:
            print(f"No input files found for sample: {sample}, continuing")
            continue
        elif len(sample_files) == 1:
            r1_file = sample_files[0]
            new_filename = f"{sample}_R1.fastq.gz"
            rename_file(r1_file, new_filename, input_dir, renaming_map, mapping_file)
        elif len(sample_files) == 2:
            r1_file = [i for i in sample_files if "R1" in i][0]
            r2_file = [i for i in sample_files if "R2" in i][0]
            new_r1 = f"{sample}_R1.fastq.gz"
            new_r2 = f"{sample}_R2.fastq.gz"
            rename_file(r1_file, new_r1, input_dir, renaming_map, mapping_file)
            rename_file(r2_file, new_r2, input_dir, renaming_map, mapping_file)
        else:
            print(f"Too many files detected for sample {sample}. Please concatenate sample files before running pipeline.")
            break

    print(f"Renaming completed. Mapping saved to {mapping_file}.")

def rename_featurecounts_bam(sample, exon_dir, intron_dir):
    """
    Rename the BAM files generated by featureCounts to predictable names.

    Args:
        sample (str): The sample name.
        exon_dir (str): Directory containing the exon BAM file.
        intron_dir (str): Directory containing the intron BAM file.

    Raises:
        FileNotFoundError: If no BAM file or multiple BAM files are found in the exon or intron directories.
    """
    # Find and rename the exon BAM file
    exon_bam_files = glob.glob(f"{exon_dir}/*.bam")
    if len(exon_bam_files) != 1:
        raise FileNotFoundError(f"Expected one BAM file in {exon_dir}, found {len(exon_bam_files)}")
    exon_bam_renamed = os.path.join(exon_dir, f"{sample}_exon.bam")
    os.rename(exon_bam_files[0], exon_bam_renamed)

    # Find and rename the intron BAM file
    intron_bam_files = glob.glob(f"{intron_dir}/*.bam")
    if len(intron_bam_files) != 1:
        raise FileNotFoundError(f"Expected one BAM file in {intron_dir}, found {len(intron_bam_files)}")
    intron_bam_renamed = os.path.join(intron_dir, f"{sample}_intron.bam")
    os.rename(intron_bam_files[0], intron_bam_renamed)

    return exon_bam_renamed, intron_bam_renamed

def check_executable(tool):
    """Check if an executable exists, otherwise log an error and exit."""
    if not shutil.which(tool):
        log_message("ERROR", f"{tool} not found! Make sure it is installed or specified in config.yaml", error=True)
        exit(1)

def log_message(step_name, message, error=False):
    """Log a timestamped message for each step."""
    log_type = "ERROR" if error else "INFO"
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    with open("results/runlog.txt", "a") as log:
        log.write(f"[{timestamp}] {log_type} - {step_name}: {message}\n")

def log_pipeline_runtime(start_time):
    """Log the total runtime of the pipeline."""
    runtime = time.time() - start_time
    log_message("Pipeline", f"Completed in {runtime:.2f} seconds")

def log_software_versions(output_file, versions):
    """Log software versions to a file."""
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    with open(output_file, "w") as log:
        log.write(f"Pipeline Run - {timestamp}\n")
        for tool, version_cmd in versions.items():
            try:
                version = subprocess.check_output(version_cmd, shell=True, text=True).strip().split("\n")[0]
                log.write(f"{tool}: {version}\n")
            except Exception as e:
                log.write(f"{tool}: Error retrieving version ({str(e)})\n")

def ensure_directories_exist(base_dirs, output_dir, samples):
    """
    Ensure that the required directories exist for each sample.

    Args:
        base_dirs (list): List of base directory names (e.g., ["results/exon", "results/intron"]).
        output_dir (str): The top-level output directory.
        samples (list): List of sample names.
    """
    for sample in samples:
        for base_dir in base_dirs:
            # Construct the full path for each sample
            full_path = os.path.join(output_dir, sample, base_dir)
            os.makedirs(full_path, exist_ok=True)

def find_bam_file(results_dir, sample_name):
    """
    Find the BAM file for a given sample in the results directory.
    """
    for root, dirs, files in os.walk(results_dir):
        for file in files:
            if file.endswith(".bam") and sample_name in file:
                return os.path.join(root, file)
    raise FileNotFoundError(f"No BAM file found for sample {sample_name} in {results_dir}")

def cleanup_pipeline_results(output_dir, sample_name):
    """
    Cleans up intermediate files and folders generated during the pipeline for a specific sample.

    Args:
        output_dir (str): Path to the top-level output directory.
        sample_name (str): Sample name to identify files to keep/remove.
    """
    # Define paths specific to the sample
    sample_results_dir = os.path.join(output_dir, sample_name, "results")
    exon_dir = os.path.join(sample_results_dir, "exon")
    intron_dir = os.path.join(sample_results_dir, "intron")
    tmp_dir = os.path.join(output_dir, sample_name, "tmp")

    # Remove exon and intron directories
    if os.path.exists(exon_dir):
        shutil.rmtree(exon_dir)
        print(f"Removed directory: {exon_dir}")
    if os.path.exists(intron_dir):
        shutil.rmtree(intron_dir)
        print(f"Removed directory: {intron_dir}")

    # Remove all BAM files except the final merged BAM and ensure the sample name is in the filename
    for file in os.listdir(sample_results_dir):
        if file.endswith(".bam") and file != f"{sample_name}_intron_exon_aligned.bam" and sample_name in file:
            file_path = os.path.join(sample_results_dir, file)
            os.remove(file_path)
            print(f"Removed file: {file_path}")

    for file in os.listdir(os.path.join(sample_results_dir, "alignment")):
        if "Aligned.sortedByCoord.out.bam" in file:
            file_path = os.path.join(sample_results_dir, "alignment", file)
            os.remove(file_path)
            print(f"Removed file: {file_path}")

    # Remove the temporary directory
    if os.path.exists(tmp_dir):
        shutil.rmtree(tmp_dir)
        print(f"Removed temporary directory: {tmp_dir}")

def revert_renaming(mapping_file="renaming_map.json"):
    """
    Revert renamed files to their original names using the renaming map.
    
    Args:
        mapping_file (str): Path to the JSON file containing the renaming map.
    """
    # Load the renaming map
    if not os.path.exists(mapping_file):
        print(f"Mapping file {mapping_file} not found. Cannot revert renaming.")
        return

    with open(mapping_file, "r") as f:
        renaming_map = json.load(f)

    # Revert the renaming
    for renamed, original in renaming_map.items():
        print(f"Reverting {renamed} to {original}")
        os.rename(renamed, original)

    # Remove the mapping file after reverting
    os.remove(mapping_file)
    print(f"Renaming reverted and mapping file {mapping_file} deleted.")